<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><link rel="icon" href="/favicon.ico"/><title>Lecture 2</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal knowledge space"/><meta property="og:title" content="Lecture 2"/><meta property="og:description" content="Personal knowledge space"/><meta property="og:url" content="https://sameep1234.github.io/notes/notes/DSqySoYnF5H5vOJ3wxCD1/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="8/28/2021"/><meta property="article:modified_time" content="8/31/2021"/><link rel="canonical" href="https://sameep1234.github.io/notes/notes/DSqySoYnF5H5vOJ3wxCD1/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/notes/_next/static/css/91bb8dcf7dd5b53c2212.css" as="style"/><link rel="stylesheet" href="/notes/_next/static/css/91bb8dcf7dd5b53c2212.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/notes/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/notes/_next/static/chunks/webpack-e9bbd759de6a360aafc5.js" defer=""></script><script src="/notes/_next/static/chunks/framework-2f612445bd50b211f15a.js" defer=""></script><script src="/notes/_next/static/chunks/main-282a13a291118b70f866.js" defer=""></script><script src="/notes/_next/static/chunks/pages/_app-22ecb5f0d31535ebfb6d.js" defer=""></script><script src="/notes/_next/static/chunks/155-51163345bd32269f413d.js" defer=""></script><script src="/notes/_next/static/chunks/pages/notes/%5Bid%5D-61b1e2653601d43c9804.js" defer=""></script><script src="/notes/_next/static/Z29MYY4IYyUA7_MtbamZt/_buildManifest.js" defer=""></script><script src="/notes/_next/static/Z29MYY4IYyUA7_MtbamZt/_ssgManifest.js" defer=""></script></head><body><div id="__next"><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px"><div class="ant-row" style="margin:0 auto"><div class="ant-col ant-col-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-16"></div></div></header><section class="ant-layout" style="margin-top:64px"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:sticky;top:64px;overflow:auto;height:calc(100vh - 64px);isolation:isolate;z-index:1;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"><div style="height:100%"><div style="display:flex;flex-direction:column;justify-content:space-between;height:100%" class="ant-col"><div class="ant-row" style="margin-left:-0.5px;margin-right:-0.5px;margin:0 auto;padding:1rem"><span class="ant-typography">ðŸŒ± with<!-- --> <a class="ant-typography" href="https://www.dendron.so/" target="_blank" rel="noopener noreferrer">Dendron ðŸŒ²</a></span></div></div></div></div></aside><main class="ant-layout-content main-content" role="main"><section class="ant-layout"></section><section class="ant-layout" style="max-width:1320px;margin:0 auto;padding:0 1.5rem"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-20"><div><h1 id="lecture-2"><a aria-hidden="true" class="anchor-heading" href="#lecture-2"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Lecture 2</h1>
<h2 id="evolution-of-os-and-kernel"><a aria-hidden="true" class="anchor-heading" href="#evolution-of-os-and-kernel"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Evolution of OS and Kernel</h2>
<h2 id="evolution-of-os"><a aria-hidden="true" class="anchor-heading" href="#evolution-of-os"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Evolution of OS</h2>
<ul>
<li>Serial Processing</li>
<li>Simple Batch Systems</li>
<li>Multiprogrammed Batch Systems</li>
<li>Time Sharing Systems</li>
<li>many others</li>
</ul>
<h2 id="serial-processing"><a aria-hidden="true" class="anchor-heading" href="#serial-processing"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Serial Processing</h2>
<ul>
<li>There was no OS.</li>
<li>To run the program, we would have to type a command for everything.</li>
<li>A program at that time was called a job which is a set of instructions along with the data on which the instructions need to be executed.</li>
<li>Issues
<ul>
<li>Scheduling
<ul>
<li>Fixed amount of time allocated to each instruction.</li>
<li>Conflict between instructions requiring more or less time.</li>
</ul>
</li>
<li>Setup Time
<ul>
<li>Loading of compiler and program is time consuming</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="simple-batch-system"><a aria-hidden="true" class="anchor-heading" href="#simple-batch-system"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Simple Batch System</h2>
<ul>
<li>Monitor Program were used which were kind of OS - A very rudimentary OS.</li>
<li>It is a software that controls the sequence of events.</li>
<li>No direct access to users unlike Serial Processing.</li>
<li>Job is submitted to an operator who batches similar instructions together and places them on the input device/hardware.</li>
<li>In this way, the time consumed is averaged out and the processor can be utilized to its maximum.</li>
<li>Control is given back to monitor after program gets terminated.</li>
</ul>
<blockquote>
<p>Monitor is a special program that manages execution of each program in the <strong>batch</strong>. It controls the sequence of events. Resident monitor (another name for simple monitor) is software always in memory. It reads in job and gives control to the processor which in turn returns the control back to monitor</p>
</blockquote>
<blockquote>
<p>Processor executes instructions from the memory i.e monitor which resides in the memory. It gains control from monitor to execute the task and once completed returns the control to monitor.</p>
</blockquote>
<blockquote>
<p>JCL (Job control language) - It is a programming language that provides instruction to the monitor about the compiler and data to be used.</p>
</blockquote>
<ul>
<li>
<p>Modes of operation</p>
<ul>
<li>User mode (Analogy: Normal Mode) - Programs submitted by the user to the memory are executed in this mode. <strong>Not all instructions may be executed.</strong></li>
<li>Kernal mode (Analogy: Admin Mode) - Part of a modern OS that actually performs I/O Management, Process Management etc. Nowadays, we have many other utility programs running which are a part of OS, but kernal is the most important one which manages the above mentioned things.</li>
</ul>
</li>
<li>
<p>Issues</p>
<ul>
<li>Processor remains idle.</li>
<li>Slow compared to processor even with automatic job sequence.</li>
</ul>
</li>
</ul>
<p><img src="/notes/assets/images/2021-08-28-23-38-27.png"></p>
<h2 id="uniprogramming"><a aria-hidden="true" class="anchor-heading" href="#uniprogramming"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Uniprogramming</h2>
<blockquote>
<p>Processor must wait for I/O instruction to complete before proceeding further.</p>
</blockquote>
<h2 id="multiprogramming"><a aria-hidden="true" class="anchor-heading" href="#multiprogramming"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Multiprogramming</h2>
<blockquote>
<p>Opposite of uniprogramming. Still there will be some waiting time but at least it can be reduced and hence is better than uniprogramming.</p>
</blockquote>
<h2 id="time-sharing-systems"><a aria-hidden="true" class="anchor-heading" href="#time-sharing-systems"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>Time sharing systems</h2>
<ul>
<li>The program is being shared through different users and different monitors. Thus, can be used to handle multiple interactive jobs.</li>
<li>Processor time is shared among multiple users.</li>
<li>This time is in milli or micro seconds. This is called short burst or quantum of computation.</li>
</ul>
<p><img src="/notes/assets/images/2021-08-29-00-06-36.png"></p>
<h2 id="os-structure"><a aria-hidden="true" class="anchor-heading" href="#os-structure"><svg aria-hidden="true" viewBox="0 0 16 16"><use xlink:href="#svg-link"></use></svg></a>OS Structure</h2>
<ul>
<li><em>For general purpose OS, the program is very large.</em></li>
<li>Ways to structure OS
<ul>
<li>Monolitic Approach (Analofy coding in C where there are no classes) - Everything combined in one place.
<ul>
<li>Eg. Older LINUX and UNIX</li>
<li>Advantages
<ul>
<li>Speed as everything is connected</li>
<li>Performance</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>Difficult to maintain and modify</li>
</ul>
</li>
</ul>
</li>
<li>Layered Approach - OS divided into number of layers.
<ul>
<li>Layer 0 = hardware and Layer n = user interface layer</li>
<li>A particular layer can use functions and services of <strong>lower-level layers only (layers below it).</strong></li>
<li>Eg. Older windows versions</li>
</ul>
</li>
<li>Microkernels - Move as much functionalities as possible to user mode from kernel mode. 
<ul>
<li>Unlike that in layered and monolithic where majority of the functionalities is available in only kernal mode.</li>
<li>I\O and interrupt management, primitive memory management, inter-process communication and basic scheduling were kept in kernel mode.</li>
<li>All other functionalities will be running in user mode.</li>
<li>Advantages
<ul>
<li>Time is reduced significantly as the time to change the mode from user to kernel and vice versa is almost completely diminished.</li>
<li>Porting of OS to newer architecture becomes easier (will be covered in upcoming lectures).</li>
<li>More reliable because less code is running in kernel mode.</li>
<li>More secure as less code has to be valudated in kernel.</li>
</ul>
</li>
<li>Disadvantages
<ul>
<li>Performance overhead to change the mode.</li>
</ul>
</li>
<li>Eg. Mach, MINIX, Windows NT Client-Server</li>
</ul>
</li>
<li>Modules - Most moedern OS implement kernel modules
<ul>
<li>These are loadable kernel module</li>
<li>Uses OOP</li>
<li>Similar to layers but is more flexible</li>
<li>Eg. Device Drivers (These are loaded as needed within the kernel)</li>
<li>Solaris Modular Approach (will be covered in upcoming lectures).</li>
</ul>
</li>
<li>Hybrid Approach - Combines multiple approaches to address performance, security and usability.
<ul>
<li>Eg. Linux and Solaris = monolithich + modular, windows = monolithic + microkernel and Mac OS and IOS = Darwin which is microkernel and BSD Unix kernel implemented over layered model</li>
</ul>
</li>
</ul>
</li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-4"><div><div class=""><div class="ant-anchor-wrapper" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#evolution-of-os-and-kernel" title="Evolution of OS and Kernel">Evolution of OS and Kernel</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#evolution-of-os" title="Evolution of OS">Evolution of OS</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#serial-processing" title="Serial Processing">Serial Processing</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#simple-batch-system" title="Simple Batch System">Simple Batch System</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#uniprogramming" title="Uniprogramming">Uniprogramming</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#multiprogramming" title="Multiprogramming">Multiprogramming</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#time-sharing-systems" title="Time sharing systems">Time sharing systems</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#os-structure" title="OS Structure">OS Structure</a></div></div></div></div></div></div></div></div></div></section><section class="ant-layout" style="max-width:1180px"><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer"></footer></section></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"DSqySoYnF5H5vOJ3wxCD1","title":"Lecture 2","vault":{"fsPath":"vault"},"type":"note","desc":"","links":[],"anchors":{"evolution-of-os-and-kernel":{"type":"header","text":"Evolution of OS and Kernel","value":"evolution-of-os-and-kernel","line":8,"column":0},"evolution-of-os":{"type":"header","text":"Evolution of OS","value":"evolution-of-os","line":10,"column":0},"serial-processing":{"type":"header","text":"Serial Processing","value":"serial-processing","line":18,"column":0},"simple-batch-system":{"type":"header","text":"Simple Batch System","value":"simple-batch-system","line":30,"column":0},"uniprogramming":{"type":"header","text":"Uniprogramming","value":"uniprogramming","line":55,"column":0},"multiprogramming":{"type":"header","text":"Multiprogramming","value":"multiprogramming","line":59,"column":0},"time-sharing-systems":{"type":"header","text":"Time sharing systems","value":"time-sharing-systems","line":63,"column":0},"os-structure":{"type":"header","text":"OS Structure","value":"os-structure","line":71,"column":0}},"fname":"courses.Semester 5.Operating System.Lecture 2","updated":1630430485504,"created":1630169451366,"parent":"OGq6U8MXIG3wwETNLR4b6","children":[],"data":{},"contentHash":"37d1940a89c1eab0615301b8bfacc25c","custom":{}},"body":"\u003ch1 id=\"lecture-2\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#lecture-2\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eLecture 2\u003c/h1\u003e\n\u003ch2 id=\"evolution-of-os-and-kernel\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#evolution-of-os-and-kernel\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eEvolution of OS and Kernel\u003c/h2\u003e\n\u003ch2 id=\"evolution-of-os\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#evolution-of-os\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eEvolution of OS\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSerial Processing\u003c/li\u003e\n\u003cli\u003eSimple Batch Systems\u003c/li\u003e\n\u003cli\u003eMultiprogrammed Batch Systems\u003c/li\u003e\n\u003cli\u003eTime Sharing Systems\u003c/li\u003e\n\u003cli\u003emany others\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"serial-processing\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#serial-processing\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eSerial Processing\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThere was no OS.\u003c/li\u003e\n\u003cli\u003eTo run the program, we would have to type a command for everything.\u003c/li\u003e\n\u003cli\u003eA program at that time was called a job which is a set of instructions along with the data on which the instructions need to be executed.\u003c/li\u003e\n\u003cli\u003eIssues\n\u003cul\u003e\n\u003cli\u003eScheduling\n\u003cul\u003e\n\u003cli\u003eFixed amount of time allocated to each instruction.\u003c/li\u003e\n\u003cli\u003eConflict between instructions requiring more or less time.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSetup Time\n\u003cul\u003e\n\u003cli\u003eLoading of compiler and program is time consuming\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"simple-batch-system\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#simple-batch-system\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eSimple Batch System\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eMonitor Program were used which were kind of OS - A very rudimentary OS.\u003c/li\u003e\n\u003cli\u003eIt is a software that controls the sequence of events.\u003c/li\u003e\n\u003cli\u003eNo direct access to users unlike Serial Processing.\u003c/li\u003e\n\u003cli\u003eJob is submitted to an operator who batches similar instructions together and places them on the input device/hardware.\u003c/li\u003e\n\u003cli\u003eIn this way, the time consumed is averaged out and the processor can be utilized to its maximum.\u003c/li\u003e\n\u003cli\u003eControl is given back to monitor after program gets terminated.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eMonitor is a special program that manages execution of each program in the \u003cstrong\u003ebatch\u003c/strong\u003e. It controls the sequence of events. Resident monitor (another name for simple monitor) is software always in memory. It reads in job and gives control to the processor which in turn returns the control back to monitor\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eProcessor executes instructions from the memory i.e monitor which resides in the memory. It gains control from monitor to execute the task and once completed returns the control to monitor.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003eJCL (Job control language) - It is a programming language that provides instruction to the monitor about the compiler and data to be used.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eModes of operation\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUser mode (Analogy: Normal Mode) - Programs submitted by the user to the memory are executed in this mode. \u003cstrong\u003eNot all instructions may be executed.\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eKernal mode (Analogy: Admin Mode) - Part of a modern OS that actually performs I/O Management, Process Management etc. Nowadays, we have many other utility programs running which are a part of OS, but kernal is the most important one which manages the above mentioned things.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIssues\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eProcessor remains idle.\u003c/li\u003e\n\u003cli\u003eSlow compared to processor even with automatic job sequence.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/notes/assets/images/2021-08-28-23-38-27.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"uniprogramming\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#uniprogramming\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eUniprogramming\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eProcessor must wait for I/O instruction to complete before proceeding further.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"multiprogramming\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#multiprogramming\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eMultiprogramming\u003c/h2\u003e\n\u003cblockquote\u003e\n\u003cp\u003eOpposite of uniprogramming. Still there will be some waiting time but at least it can be reduced and hence is better than uniprogramming.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"time-sharing-systems\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#time-sharing-systems\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eTime sharing systems\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eThe program is being shared through different users and different monitors. Thus, can be used to handle multiple interactive jobs.\u003c/li\u003e\n\u003cli\u003eProcessor time is shared among multiple users.\u003c/li\u003e\n\u003cli\u003eThis time is in milli or micro seconds. This is called short burst or quantum of computation.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/notes/assets/images/2021-08-29-00-06-36.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"os-structure\"\u003e\u003ca aria-hidden=\"true\" class=\"anchor-heading\" href=\"#os-structure\"\u003e\u003csvg aria-hidden=\"true\" viewBox=\"0 0 16 16\"\u003e\u003cuse xlink:href=\"#svg-link\"\u003e\u003c/use\u003e\u003c/svg\u003e\u003c/a\u003eOS Structure\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eFor general purpose OS, the program is very large.\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eWays to structure OS\n\u003cul\u003e\n\u003cli\u003eMonolitic Approach (Analofy coding in C where there are no classes) - Everything combined in one place.\n\u003cul\u003e\n\u003cli\u003eEg. Older LINUX and UNIX\u003c/li\u003e\n\u003cli\u003eAdvantages\n\u003cul\u003e\n\u003cli\u003eSpeed as everything is connected\u003c/li\u003e\n\u003cli\u003ePerformance\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDisadvantages\n\u003cul\u003e\n\u003cli\u003eDifficult to maintain and modify\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eLayered Approach - OS divided into number of layers.\n\u003cul\u003e\n\u003cli\u003eLayer 0 = hardware and Layer n = user interface layer\u003c/li\u003e\n\u003cli\u003eA particular layer can use functions and services of \u003cstrong\u003elower-level layers only (layers below it).\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eEg. Older windows versions\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eMicrokernels - Move as much functionalities as possible to user mode from kernel mode. \n\u003cul\u003e\n\u003cli\u003eUnlike that in layered and monolithic where majority of the functionalities is available in only kernal mode.\u003c/li\u003e\n\u003cli\u003eI\\O and interrupt management, primitive memory management, inter-process communication and basic scheduling were kept in kernel mode.\u003c/li\u003e\n\u003cli\u003eAll other functionalities will be running in user mode.\u003c/li\u003e\n\u003cli\u003eAdvantages\n\u003cul\u003e\n\u003cli\u003eTime is reduced significantly as the time to change the mode from user to kernel and vice versa is almost completely diminished.\u003c/li\u003e\n\u003cli\u003ePorting of OS to newer architecture becomes easier (will be covered in upcoming lectures).\u003c/li\u003e\n\u003cli\u003eMore reliable because less code is running in kernel mode.\u003c/li\u003e\n\u003cli\u003eMore secure as less code has to be valudated in kernel.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDisadvantages\n\u003cul\u003e\n\u003cli\u003ePerformance overhead to change the mode.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eEg. Mach, MINIX, Windows NT Client-Server\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eModules - Most moedern OS implement kernel modules\n\u003cul\u003e\n\u003cli\u003eThese are loadable kernel module\u003c/li\u003e\n\u003cli\u003eUses OOP\u003c/li\u003e\n\u003cli\u003eSimilar to layers but is more flexible\u003c/li\u003e\n\u003cli\u003eEg. Device Drivers (These are loaded as needed within the kernel)\u003c/li\u003e\n\u003cli\u003eSolaris Modular Approach (will be covered in upcoming lectures).\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHybrid Approach - Combines multiple approaches to address performance, security and usability.\n\u003cul\u003e\n\u003cli\u003eEg. Linux and Solaris = monolithich + modular, windows = monolithic + microkernel and Mac OS and IOS = Darwin which is microkernel and BSD Unix kernel implemented over layered model\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"JEvRiJuvqz4mJX4q7zqJs","title":"Curated Notes","vault":{"fsPath":"vault"},"type":"note","desc":"","links":[],"anchors":{},"fname":"root","updated":1630150480330,"created":1629975412335,"parent":null,"children":["Jq5ki9jf1QLTdc3DYLRW4","3ONxZ3Khb7nFPdLxlV1ib"],"data":{},"contentHash":"f8f9737444f7022ec433cdb6d3c7a764","custom":{"nav_order":0,"permalink":"/"},"body":"\n\r\n\r\nYou have reached the home page of my curated notes. I am a third year student pursuing Computer Science and Engineering at Ahmedabad University.\r\n\r\nFeel free to use this resource to its best potential and reach out to me on [Linkedin](https://www.linkedin.com/in/sameep-vani/) and do checkout my [GitHub](https://github.com/Sameep1234)\r\n"},"collectionChildren":null,"customHeadContent":null,"config":{"useFMTitle":true,"useNoteTitleForLink":true,"mermaid":true,"useKatex":true,"dev":{"enablePreviewV2":true},"site":{"siteUrl":"https://sameep1234.github.io","assetsPrefix":"/notes","copyAssets":true,"siteHierarchies":["root"],"siteRootDir":"docs","usePrettyRefs":true,"title":"Sameep","description":"Personal knowledge space","duplicateNoteBehavior":{"action":"useVault","payload":["vault"]},"author":"Sameep","logo":"vault/logo.gif","ga_tracking":"G-VZ67P3SVZE","siteLastModified":true,"gh_edit_branch":"main","usePrettyLinks":true,"siteNotesDir":"notes","siteFaviconPath":"favicon.ico","gh_edit_link":true,"gh_edit_link_text":"Edit this page on GitHub","gh_root":"docs/","gh_edit_view_mode":"edit","writeStubs":true,"siteIndex":"root"},"version":4,"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":false,"leaveTrace":false,"bubbleUpCreateNew":true}},"randomNote":{},"insertNote":{"initialValue":"templates"},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false}},"workspace":{"dendronVersion":"0.70.0","vaults":[{"fsPath":"vault"}],"journal":{"dailyDomain":"daily","name":"journalc","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"graph":{"zoomSpeed":1},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableUserTags":true,"enableHashTags":true,"task":{"name":"","dateFormat":"","addBehavior":"childOfCurrent","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"}},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableMermaid":true,"enablePrettyRefs":true,"enableKatex":true}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"DSqySoYnF5H5vOJ3wxCD1"},"buildId":"Z29MYY4IYyUA7_MtbamZt","assetPrefix":"/notes","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>